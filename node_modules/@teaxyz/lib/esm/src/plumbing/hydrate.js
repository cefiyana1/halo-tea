import * as semver from "../utils/semver.js";
import usePantry from "../hooks/usePantry.js";
import { is_what } from "../deps.js";
const { isArray } = is_what;
const get = (x) => usePantry().project(x).runtime.deps();
/// sorts a list of packages topologically based on their
/// dependencies. Throws if there is a cycle in the input.
/// ignores changes in dependencies based on versions
export default async function hydrate(input, get_deps = get) {
    if (!isArray(input))
        input = [input];
    const dry = condense(input.map(spec => {
        if ("version" in spec) {
            return { project: spec.project, constraint: new semver.Range(`=${spec.version}`) };
        }
        else {
            return spec;
        }
    }));
    const graph = {};
    const bootstrap = new Set();
    const initial_set = new Set(dry.map(x => x.project));
    const go = async (target) => {
        /// we trace up a target pkgâ€™s dependency graph
        /// the target pkg is thus the youngest child and we are ascending up its parents
        const ascend = async (node, children) => {
            for (const dep of await get_deps(node.pkg, initial_set.has(node.project))) {
                if (children.has(dep.project)) {
                    if (!bootstrap.has(dep.project)) {
                        console.warn(`tea: cyclic dep: ${dep.project}: ${node.project}`);
                        //TODO the bootstrap should keep the version constraint since it may be different
                        bootstrap.add(dep.project);
                    }
                }
                else {
                    const found = graph[dep.project];
                    if (found) {
                        /// we already traced this graph
                        if (found.count() < node.count()) {
                            found.parent = node;
                        }
                        //FIXME strictly we only have to constrain graphs that contain linkage
                        // ie. you cannot have a binary that links two separate versions of eg. openssl
                        // or (maybe) services, eg. you might suffer if there are two versions of postgres running (though tea mitigates this)
                        found.pkg.constraint = semver.intersect(found.pkg.constraint, dep.constraint);
                    }
                    else {
                        const new_node = new Node(dep, node);
                        graph[dep.project] = new_node;
                        await ascend(new_node, new Set([...children, dep.project]));
                    }
                }
            }
        };
        await ascend(target, new Set([target.project]));
    };
    for (const pkg of dry) {
        if (pkg.project in graph) {
            graph[pkg.project].pkg.constraint = semver.intersect(graph[pkg.project].pkg.constraint, pkg.constraint);
        }
        else {
            const new_node = new Node(pkg);
            graph[pkg.project] = new_node;
            await go(new_node);
        }
    }
    const pkgs = Object.values(graph)
        .sort((a, b) => b.count() - a.count())
        .map(({ pkg }) => pkg);
    //TODO strictly we need to record precisely the bootstrap version constraint
    const bootstrap_required = new Set(pkgs.compact(({ project }) => bootstrap.has(project) && project));
    return {
        pkgs,
        dry: pkgs.filter(({ project }) => initial_set.has(project)),
        wet: pkgs.filter(({ project }) => !initial_set.has(project) || bootstrap_required.has(project)),
        bootstrap_required
    };
}
function condense(pkgs) {
    const out = [];
    for (const pkg of pkgs) {
        const found = out.find(x => x.project === pkg.project);
        if (found) {
            found.constraint = semver.intersect(found.constraint, pkg.constraint);
        }
        else {
            out.push(pkg);
        }
    }
    return out;
}
/////////////////////////////////////////////////////////////////////////// lib
class Node {
    constructor(pkg, parent) {
        Object.defineProperty(this, "parent", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "pkg", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "project", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.parent = parent;
        this.pkg = pkg;
        this.project = pkg.project;
    }
    count() {
        let n = 0;
        let node = this;
        // deno-lint-ignore no-cond-assign
        while (node = node?.parent)
            n++;
        return n;
    }
}
