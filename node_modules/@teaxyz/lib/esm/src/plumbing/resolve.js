import useInventory from "../hooks/useInventory.js";
import { str as pkgstr } from "../utils/pkg.js";
import useCellar from "../hooks/useCellar.js";
import { TeaError } from "../utils/error.js";
export class ResolveError extends TeaError {
    constructor(pkg) {
        super(`not-found: pkg: ${pkgstr(pkg)}`);
        Object.defineProperty(this, "pkg", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.pkg = pkg;
    }
}
/// resolves a list of package specifications based on what is available in
/// bottle storage if `update` is false we will return already installed pkgs
/// that resolve so if we are resolving `node>=12`, node 13 is installed, but
/// node 19 is the latest we return node 13. if `update` is true we return node
/// 19 and *you will need to install it*.
export default async function resolve(reqs, { update } = { update: false }) {
    const inventory = _internals.useInventory();
    const cellar = _internals.useCellar();
    const rv = { pkgs: [], installed: [], pending: [] };
    let installation;
    for (const req of reqs) {
        if (!update && (installation = await cellar.has(req))) {
            // if something is already installed that satisfies the constraint then use it
            rv.installed.push(installation);
            rv.pkgs.push(installation.pkg);
        }
        else {
            const version = await inventory.select(req);
            if (!version) {
                throw new ResolveError(req);
            }
            const pkg = { version, project: req.project };
            rv.pkgs.push(pkg);
            if ((installation = await cellar.has(pkg))) {
                rv.installed.push(installation);
            }
            else {
                rv.pending.push(pkg);
            }
        }
    }
    return rv;
}
export const _internals = {
    useInventory,
    useCellar
};
