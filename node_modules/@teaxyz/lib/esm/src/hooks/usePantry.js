import * as dntShim from "../../_dnt.shims.js";
import { is_what } from "../deps.js";
const { isNumber, isPlainObject, isString, isArray, isPrimitive, isBoolean } = is_what;
import { validatePackageRequirement } from "../utils/hacks.js";
import useMoustaches from "./useMoustaches.js";
import { TeaError } from "../utils/error.js";
import { validate } from "../utils/misc.js";
import useConfig from "./useConfig.js";
import host from "../utils/host.js";
import Path from "../utils/Path.js";
export class PantryError extends TeaError {
}
export class PantryParseError extends PantryError {
    constructor(project, path, cause) {
        super(`package.yml parse error: ${path ?? project}`);
        Object.defineProperty(this, "project", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "path", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.project = project;
        this.path = path;
        this.cause = cause;
    }
}
export class PackageNotFoundError extends PantryError {
    constructor(project) {
        super(`pkg not found: ${project}`);
        Object.defineProperty(this, "project", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.project = project;
    }
}
export class PantryNotFoundError extends PantryError {
    constructor(path) {
        super(`pantry not found: ${path}`);
    }
}
export default function usePantry() {
    const config = useConfig();
    const prefix = config.prefix.join('tea.xyz/var/pantry/projects');
    async function* ls() {
        for (const prefix of pantry_paths()) {
            for await (const path of _ls_pantry(prefix)) {
                yield {
                    project: path.parent().relative({ to: prefix }),
                    path
                };
            }
        }
    }
    const project = (input) => {
        const project = isString(input) ? input : input.project;
        const yaml = (() => {
            for (const prefix of pantry_paths()) {
                if (!prefix.exists())
                    throw new PantryNotFoundError(prefix.parent());
                const dir = prefix.join(project);
                const filename = dir.join("package.yml");
                if (!filename.exists())
                    continue;
                let memo;
                return () => memo ?? (memo = filename.readYAML()
                    .then(validate.obj)
                    .catch(cause => { throw new PantryParseError(project, filename, cause); }));
            }
            throw new PackageNotFoundError(project);
        })();
        const companions = async () => parse_pkgs_node((await yaml())["companions"]);
        const runtime_env = async (version, deps) => {
            const yml = await yaml();
            const obj = validate.obj(yml["runtime"]?.["env"] ?? {});
            return expand_env_obj(obj, { project, version }, deps);
        };
        const available = async () => {
            let { platforms } = await yaml();
            if (!platforms)
                return true;
            if (isString(platforms))
                platforms = [platforms];
            if (!isArray(platforms))
                throw new PantryParseError(project);
            return platforms.includes(host().platform) || platforms.includes(`${host().platform}/${host().arch}`);
        };
        const drydeps = async () => parse_pkgs_node((await yaml()).dependencies);
        const provides = async () => {
            let node = (await yaml())["provides"];
            if (!node)
                return [];
            if (isPlainObject(node)) {
                node = node[host().platform];
            }
            if (!isArray(node))
                throw new PantryParseError(project);
            return node.compact(x => {
                if (isPlainObject(x)) {
                    x = x["executable"];
                }
                if (isString(x)) {
                    if (x.startsWith("bin/"))
                        return x.slice(4);
                    if (x.startsWith("sbin/"))
                        return x.slice(5);
                }
            });
        };
        const provider = async () => {
            for (const prefix of pantry_paths()) {
                if (!prefix.exists())
                    continue;
                const dir = prefix.join(project);
                const filename = dir.join("provider.yml");
                if (!filename.exists())
                    continue;
                const yaml = validate.obj(await filename.readYAML());
                const cmds = validate.arr(yaml.cmds);
                return (binname) => {
                    if (!cmds.includes(binname))
                        return;
                    const args = yaml['args'];
                    if (isPlainObject(args)) {
                        if (args[binname]) {
                            return get_args(args[binname]);
                        }
                        else {
                            return get_args(args['...']);
                        }
                    }
                    else {
                        return get_args(args);
                    }
                };
            }
            function get_args(input) {
                if (isString(input)) {
                    return input.split(/\s+/);
                }
                else {
                    return validate.arr(input);
                }
            }
        };
        return {
            companions,
            runtime: {
                env: runtime_env,
                deps: drydeps
            },
            available,
            provides,
            provider,
            yaml
        };
    };
    async function which({ interprets: extension }) {
        if (extension[0] == '.')
            extension = extension.slice(1);
        if (!extension)
            return;
        for await (const pkg of ls()) {
            const yml = await project(pkg).yaml();
            const node = yml["interprets"];
            if (!isPlainObject(node))
                continue;
            try {
                const { extensions, args } = yml["interprets"];
                if ((isString(extensions) && extensions === extension) ||
                    (isArray(extensions) && extensions.includes(extension))) {
                    return { project: pkg.project, args: isArray(args) ? args : [args] };
                }
            }
            catch {
                continue;
            }
        }
        return undefined;
    }
    const missing = () => !prefix.exists();
    const neglected = () => {
        const stat = dntShim.Deno.statSync(prefix.string);
        if (!stat.mtime)
            return true;
        return (Date.now() - stat.mtime.getTime()) > 24 * 60 * 60 * 1000;
    };
    return {
        prefix,
        which,
        ls,
        project,
        parse_pkgs_node,
        expand_env_obj,
        missing,
        neglected
    };
    function pantry_paths() {
        const rv = [];
        if (prefix.isDirectory()) {
            rv.push(prefix);
        }
        for (const path of config.pantries.reverse()) {
            rv.unshift(path.join("projects"));
        }
        if (rv.length == 0) {
            throw new PantryNotFoundError(prefix);
        }
        return rv;
    }
}
// deno-lint-ignore no-explicit-any
export function parse_pkgs_node(node) {
    if (!node)
        return [];
    node = validate.obj(node);
    platform_reduce(node);
    return Object.entries(node)
        .compact(([project, constraint]) => validatePackageRequirement(project, constraint));
}
/// expands platform specific keys into the object
/// expands inplace because JS is nuts and you have to suck it up
function platform_reduce(env) {
    const sys = host();
    for (const [key, value] of Object.entries(env)) {
        const [os, arch] = (() => {
            let match = key.match(/^(darwin|linux)\/(aarch64|x86-64)$/);
            if (match)
                return [match[1], match[2]];
            if ((match = key.match(/^(darwin|linux)$/)))
                return [match[1]];
            if ((match = key.match(/^(aarch64|x86-64)$/)))
                return [, match[1]];
            return [];
        })();
        if (!os && !arch)
            continue;
        delete env[key];
        if (os && os != sys.platform)
            continue;
        if (arch && arch != sys.arch)
            continue;
        const dict = validate.obj(value);
        for (const [key, value] of Object.entries(dict)) {
            // if user specifies an array then we assume we are supplementing
            // otherwise we are replacing. If this is too magical let us know
            if (isArray(value)) {
                if (!env[key])
                    env[key] = [];
                else if (!isArray(env[key]))
                    env[key] = [env[key]];
                //TODO if all-platforms version comes after the specific then order accordingly
                env[key].push(...value);
            }
            else {
                env[key] = value;
            }
        }
    }
}
export function expand_env_obj(env_, pkg, deps) {
    const env = { ...env_ };
    platform_reduce(env);
    const rv = {};
    for (let [key, value] of Object.entries(env)) {
        if (isArray(value)) {
            value = value.map(x => transform(x)).join(" ");
        }
        else {
            value = transform(value);
        }
        rv[key] = value;
    }
    return rv;
    // deno-lint-ignore no-explicit-any
    function transform(value) {
        if (!isPrimitive(value))
            throw new PantryParseError(pkg.project, undefined, JSON.stringify(value));
        if (isBoolean(value)) {
            return value ? "1" : "0";
        }
        else if (value === undefined || value === null) {
            return "0";
        }
        else if (isString(value)) {
            const mm = useMoustaches();
            const home = Path.home().string;
            const obj = [
                { from: 'env.HOME', to: home },
                { from: 'home', to: home } // remove, stick with just ~
            ];
            obj.push(...mm.tokenize.all(pkg, deps));
            return mm.apply(value, obj);
        }
        else if (isNumber(value)) {
            return value.toString();
        }
        const e = new Error("unexpected error");
        e.cause = value;
        throw e;
    }
}
async function* _ls_pantry(dir) {
    if (!dir.isDirectory())
        throw new PantryNotFoundError(dir);
    for await (const [path, { name, isDirectory }] of dir.ls()) {
        if (isDirectory) {
            for await (const x of _ls_pantry(path)) {
                yield x;
            }
        }
        else if (name === "package.yml" || name === "package.yaml") {
            yield path;
        }
    }
}
