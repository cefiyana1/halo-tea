import * as dntShim from "../../_dnt.shims.js";
import install from "../plumbing/install.js";
import useShellEnv from '../hooks/useShellEnv.js';
import usePantry from '../hooks/usePantry.js';
import hydrate from "../plumbing/hydrate.js";
import resolve from "../plumbing/resolve.js";
import { TeaError } from "../utils/error.js";
import { spawn } from "child_process";
import useSync from "../hooks/useSync.js";
import which from "../plumbing/which.js";
import link from "../plumbing/link.js";
import { is_what } from "../deps.js";
const { isArray } = is_what;
export default async function run(cmd, opts) {
    const { usesh, arg0: whom } = (() => {
        if (!isArray(cmd)) {
            const s = cmd.trim();
            const i = s.indexOf(' ');
            if (i == -1) {
                cmd = [];
                return { usesh: false, arg0: s };
            }
            else {
                const arg0 = s.slice(0, i);
                cmd = s.slice(i + 1);
                return { usesh: true, arg0 };
            }
        }
        else if (cmd.length == 0) {
            throw new RunError('EUSAGE', `\`cmd\` evaluated empty: ${cmd}`);
        }
        else {
            return {
                usesh: false,
                arg0: cmd.shift().toString().trim()
            };
        }
    })();
    const { env, shebang } = await setup(whom, opts?.env ?? dntShim.Deno.env.toObject(), opts?.logger);
    const arg0 = usesh ? '/bin/sh' : shebang.shift();
    const args = usesh
        ? ['-c', `${shebang.join(' ')} ${cmd}`]
        : [...shebang, ...cmd.map(x => x.toString())];
    return new Promise((resolve, reject) => {
        const proc = spawn(arg0, args, {
            env,
            stdio: [
                "pipe",
                opts?.stdout ? 'pipe' : 'inherit',
                opts?.stderr ? 'pipe' : 'inherit'
            ]
        });
        let stdout = '', stderr = '';
        proc.stdout?.on('data', data => stdout += data);
        proc.stderr?.on('data', data => stderr += data);
        proc.on('close', status => {
            if (status && !opts?.status) {
                const err = new RunError('EIO', `${cmd} exited with: ${status}`);
                err.cause = status;
                reject(err);
            }
            else {
                const fulfill = resolve;
                fulfill({ stdout, stderr, status });
            }
        });
    });
}
async function setup(cmd, env, logger) {
    const pantry = usePantry();
    const sh = useShellEnv();
    if (pantry.missing() || pantry.neglected()) {
        await useSync();
    }
    const wut = await which(cmd);
    if (!wut)
        throw new RunError('ENOENT', `No project in pantry provides ${cmd}`);
    const { pkgs } = await hydrate(wut);
    const { pending, installed } = await resolve(pkgs);
    for (const pkg of pending) {
        const installation = await install(pkg, logger);
        await link(installation);
        installed.push(installation);
    }
    const pkgenv = await sh.map({ installations: installed });
    for (const [key, value] of Object.entries(env)) {
        if (!value) {
            continue;
        }
        else if (pkgenv[key]) {
            pkgenv[key].push(value);
        }
        else {
            pkgenv[key] = [value];
        }
    }
    return { env: sh.flatten(pkgenv), shebang: wut.shebang };
}
export class RunError extends TeaError {
    constructor(code, message) {
        super(message);
        Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.code = code;
    }
}
