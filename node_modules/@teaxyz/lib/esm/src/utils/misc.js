//CONTRACT you canâ€™t use anything from hooks
import { is_what } from "../deps.js";
const { isPlainObject, isArray } = is_what;
function validate_str(input) {
    if (typeof input == 'boolean')
        return input ? 'true' : 'false';
    if (typeof input == 'number')
        return input.toString();
    if (typeof input != 'string')
        throw new Error(`not-string: ${input}`);
    return input;
}
function validate_plain_obj(input) {
    if (!isPlainObject(input))
        throw new Error(`not-plain-obj: ${JSON.stringify(input)}`);
    return input;
}
function validate_arr(input) {
    if (!isArray(input))
        throw new Error(`not-array: ${JSON.stringify(input)}`);
    return input;
}
const validate = {
    str: validate_str,
    obj: validate_plain_obj,
    arr: validate_arr
};
export { validate };
Set.prototype.insert = function (t) {
    if (this.has(t)) {
        return { inserted: false };
    }
    else {
        this.add(t);
        return { inserted: true };
    }
};
Array.prototype.compact = function (body, opts) {
    const rv = [];
    for (const e of this) {
        try {
            const f = body ? body(e) : e;
            if (f)
                rv.push(f);
        }
        catch (err) {
            if (opts === undefined || opts.rescue === false)
                throw err;
        }
    }
    return rv;
};
export function flatmap(t, body, opts) {
    try {
        if (t)
            return body(t) ?? undefined;
    }
    catch (err) {
        if (!opts?.rescue)
            throw err;
    }
}
export async function async_flatmap(t, body, opts) {
    try {
        const tt = await t;
        if (tt)
            return await body(tt) ?? undefined;
    }
    catch (err) {
        if (!opts?.rescue)
            throw err;
    }
}
String.prototype.chuzzle = function () {
    return this.trim() || undefined;
};
Number.prototype.chuzzle = function () {
    return Number.isNaN(this) ? undefined : this;
};
