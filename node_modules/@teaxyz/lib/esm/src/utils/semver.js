//HEY YOU! DO NOT CHANGE THIS TO USE deps.ts since it breaks tea/gui
import { isArray, isString } from "is-what";
/**
 * we have our own implementation because open source is full of weird
 * but *almost* valid semver schemes, eg:
   * openssl 1.1.1q
   * ghc 5.64.3.2
 * it also allows us to implement semver_intersection without hating our lives
 */
export default class SemVer {
    constructor(input) {
        Object.defineProperty(this, "components", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "major", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "minor", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "patch", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        //FIXME parse these
        Object.defineProperty(this, "prerelease", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "build", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "raw", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "pretty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (typeof input == 'string') {
            const vprefix = input.startsWith('v');
            const raw = vprefix ? input.slice(1) : input;
            const parts = raw.split('.');
            let pretty_is_raw = false;
            this.components = parts.flatMap((x, index) => {
                const match = x.match(/^(\d+)([a-z])$/);
                if (match) {
                    if (index != parts.length - 1)
                        throw new Error(`invalid version: ${input}`);
                    const n = parseInt(match[1]);
                    if (isNaN(n))
                        throw new Error(`invalid version: ${input}`);
                    pretty_is_raw = true;
                    return [n, char_to_num(match[2])];
                }
                else if (/^\d+$/.test(x)) {
                    const n = parseInt(x); // parseInt will parse eg. `5-start` to `5`
                    if (isNaN(n))
                        throw new Error(`invalid version: ${input}`);
                    return [n];
                }
                else {
                    throw new Error(`invalid version: ${input}`);
                }
            });
            this.raw = raw;
            if (pretty_is_raw)
                this.pretty = raw;
        }
        else if (input instanceof Range || input instanceof SemVer) {
            const v = input instanceof Range ? input.single() : input;
            if (!v)
                throw new Error(`range represents more than a single version: ${input}`);
            this.components = v.components;
            this.raw = v.raw;
            this.pretty = v.pretty;
        }
        else {
            this.components = input;
            this.raw = input.join('.');
        }
        this.major = this.components[0];
        this.minor = this.components[1] ?? 0;
        this.patch = this.components[2] ?? 0;
        function char_to_num(c) {
            return c.charCodeAt(0) - 'a'.charCodeAt(0) + 1;
        }
    }
    toString() {
        return this.pretty ??
            (this.components.length <= 3
                ? `${this.major}.${this.minor}.${this.patch}`
                : this.components.join('.'));
    }
    eq(that) {
        return this.compare(that) == 0;
    }
    neq(that) {
        return this.compare(that) != 0;
    }
    gt(that) {
        return this.compare(that) > 0;
    }
    gte(that) {
        return this.compare(that) >= 0;
    }
    lt(that) {
        return this.compare(that) < 0;
    }
    lte(that) {
        return this.compare(that) <= 0;
    }
    compare(that) {
        return _compare(this, that);
    }
    [Symbol.for("Deno.customInspect")]() {
        return this.toString();
    }
}
/// the same as the constructor but swallows the error returning undefined instead
/// also slightly more tolerant parsing
export function parse(input) {
    try {
        return new SemVer(input);
    }
    catch {
        return undefined;
    }
}
/// determines if the input is in fact a valid semantic version
export function isValid(input) {
    return parse(input) !== undefined;
}
/// we don’t support as much as node-semver but we refuse to do so because it is badness
export class Range {
    constructor(input) {
        // contract [0, 1] where 0 != 1 and 0 < 1
        Object.defineProperty(this, "set", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (input === "*") {
            this.set = '*';
        }
        else if (!isString(input)) {
            this.set = input;
        }
        else {
            input = input.trim();
            const err = () => new Error(`invalid semver range: ${input}`);
            this.set = input.split(/(?:,|\s*\|\|\s*)/).map(input => {
                let match = input.match(/^>=((\d+\.)*\d+)\s*(<((\d+\.)*\d+))?$/);
                if (match) {
                    const v1 = new SemVer(match[1]);
                    const v2 = match[3] ? new SemVer(match[4]) : new SemVer([Infinity, Infinity, Infinity]);
                    return [v1, v2];
                }
                else if ((match = input.match(/^([~=<^@])(.+)$/))) {
                    let v1, v2;
                    switch (match[1]) {
                        // deno-lint-ignore no-case-declarations
                        case "^":
                            v1 = new SemVer(match[2]);
                            const parts = [];
                            for (let i = 0; i < v1.components.length; i++) {
                                if (v1.components[i] === 0 && i < v1.components.length - 1) {
                                    parts.push(0);
                                }
                                else {
                                    parts.push(v1.components[i] + 1);
                                    break;
                                }
                            }
                            v2 = new SemVer(parts);
                            return [v1, v2];
                        case "~":
                            {
                                v1 = new SemVer(match[2]);
                                if (v1.components.length == 1) {
                                    // yep this is the official policy
                                    v2 = new SemVer([v1.major + 1]);
                                }
                                else {
                                    v2 = new SemVer([v1.major, v1.minor + 1]);
                                }
                            }
                            return [v1, v2];
                        case "<":
                            v1 = new SemVer([0]);
                            v2 = new SemVer(match[2]);
                            return [v1, v2];
                        case "=":
                            return new SemVer(match[2]);
                        case "@": {
                            // @ is not a valid semver operator, but people expect it to work like so:
                            // @5 => latest 5.x (ie ^5)
                            // @5.1 => latest 5.1.x (ie. ~5.1)
                            // @5.1.0 => latest 5.1.0 (usually 5.1.0 since most stuff hasn't got more digits)
                            const parts = match[2].split(".").map(x => parseInt(x));
                            v1 = new SemVer(parts);
                            const last = parts.pop();
                            v2 = new SemVer([...parts, last + 1]);
                            return [v1, v2];
                        }
                    }
                }
                throw err();
            });
            /// I think this is an impossible state but let’s be sure
            if (this.set.length == 0)
                throw err();
            for (const i of this.set) {
                if (isArray(i) && !i[0].lt(i[1]))
                    throw err();
            }
        }
    }
    toString() {
        if (this.set === '*') {
            return '*';
        }
        else {
            return this.set.map(v => {
                if (!isArray(v))
                    return `=${v.toString()}`;
                const [v1, v2] = v;
                if (v1.major > 0 && v2.major == v1.major + 1 && v2.minor == 0 && v2.patch == 0) {
                    const v = chomp(v1);
                    return `^${v}`;
                }
                else if (v2.major == v1.major && v2.minor == v1.minor + 1 && v2.patch == 0) {
                    const v = chomp(v1);
                    return `~${v}`;
                }
                else if (v2.major == Infinity) {
                    const v = chomp(v1);
                    return `>=${v}`;
                }
                else {
                    return `>=${chomp(v1)}<${chomp(v2)}`;
                }
            }).join(",");
        }
    }
    // eq(that: Range): boolean {
    //   if (this.set.length !== that.set.length) return false
    //   for (let i = 0; i < this.set.length; i++) {
    //     const [a,b] = [this.set[i], that.set[i]]
    //     if (typeof a !== 'string' && typeof b !== 'string') {
    //       if (a[0].neq(b[0])) return false
    //       if (a[1].neq(b[1])) return false
    //     } else if (a != b) {
    //       return false
    //     }
    //   }
    //   return true
    // }
    /// tolerant to stuff in the wild that hasn’t semver specifiers
    static parse(input) {
        if (!input)
            return;
        input = input.toString();
        try {
            return new Range(input);
        }
        catch {
            if (!/^(\d+\.)*\d+$/.test(input))
                return;
            // AFAICT this is what people expect
            // verified via https://jubianchi.github.io/semver-check/
            const parts = input.split('.');
            if (parts.length < 3) {
                return new Range(`^${input}`);
            }
            else {
                return new Range(`~${input}`);
            }
        }
    }
    satisfies(version) {
        if (this.set === '*') {
            return true;
        }
        else {
            return this.set.some(v => {
                if (isArray(v)) {
                    const [v1, v2] = v;
                    return version.compare(v1) >= 0 && version.compare(v2) < 0;
                }
                else {
                    return version.eq(v);
                }
            });
        }
    }
    max(versions) {
        return versions.filter(x => this.satisfies(x)).sort((a, b) => a.compare(b)).pop();
    }
    single() {
        if (this.set === '*')
            return;
        if (this.set.length > 1)
            return;
        return isArray(this.set[0]) ? undefined : this.set[0];
    }
    [Symbol.for("Deno.customInspect")]() {
        return this.toString();
    }
}
function zip(a, b) {
    const N = Math.max(a.length, b.length);
    const rv = [];
    for (let i = 0; i < N; ++i) {
        rv.push([a[i], b[i]]);
    }
    return rv;
}
function _compare(a, b) {
    for (const [c, d] of zip(cmpcomponents(a), cmpcomponents(b))) {
        if (c != d)
            return (c ?? 0) - (d ?? 0);
    }
    return 0;
    /// we sort calver before semver, mainly because we label pre-releases with calver
    /// we worry that one day we will severely regret this but… it’s what we do for now
    function cmpcomponents(v) {
        if (v.major > 1996 && v.major != Infinity) {
            return [0, 0, 0, ...v.components];
        }
        else {
            return v.components;
        }
    }
}
export { _compare as compare };
export function intersect(a, b) {
    if (b.set === '*')
        return a;
    if (a.set === '*')
        return b;
    // calculate the intersection between two semver.Ranges
    const set = [];
    for (const aa of a.set) {
        for (const bb of b.set) {
            if (!isArray(aa) && !isArray(bb)) {
                if (aa.eq(bb))
                    set.push(aa);
            }
            else if (!isArray(aa)) {
                const bbb = bb;
                if (aa.compare(bbb[0]) >= 0 && aa.lt(bbb[1]))
                    set.push(aa);
            }
            else if (!isArray(bb)) {
                const aaa = aa;
                if (bb.compare(aaa[0]) >= 0 && bb.lt(aaa[1]))
                    set.push(bb);
            }
            else {
                const a1 = aa[0];
                const a2 = aa[1];
                const b1 = bb[0];
                const b2 = bb[1];
                if (a1.compare(b2) >= 0 || b1.compare(a2) >= 0) {
                    continue;
                }
                set.push([a1.compare(b1) > 0 ? a1 : b1, a2.compare(b2) < 0 ? a2 : b2]);
            }
        }
    }
    if (set.length <= 0)
        throw new Error(`cannot intersect: ${a} && ${b}`);
    return new Range(set);
}
//FIXME yes yes this is not sufficient
export const regex = /\d+\.\d+\.\d+/;
function chomp(v) {
    return v.toString().replace(/(\.0)+$/g, '') || '0';
}
