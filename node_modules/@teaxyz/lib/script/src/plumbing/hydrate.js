"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const semver = __importStar(require("../utils/semver.js"));
const usePantry_js_1 = __importDefault(require("../hooks/usePantry.js"));
const deps_js_1 = require("../deps.js");
const { isArray } = deps_js_1.is_what;
const get = (x) => (0, usePantry_js_1.default)().project(x).runtime.deps();
/// sorts a list of packages topologically based on their
/// dependencies. Throws if there is a cycle in the input.
/// ignores changes in dependencies based on versions
async function hydrate(input, get_deps = get) {
    if (!isArray(input))
        input = [input];
    const dry = condense(input.map(spec => {
        if ("version" in spec) {
            return { project: spec.project, constraint: new semver.Range(`=${spec.version}`) };
        }
        else {
            return spec;
        }
    }));
    const graph = {};
    const bootstrap = new Set();
    const initial_set = new Set(dry.map(x => x.project));
    const go = async (target) => {
        /// we trace up a target pkgâ€™s dependency graph
        /// the target pkg is thus the youngest child and we are ascending up its parents
        const ascend = async (node, children) => {
            for (const dep of await get_deps(node.pkg, initial_set.has(node.project))) {
                if (children.has(dep.project)) {
                    if (!bootstrap.has(dep.project)) {
                        console.warn(`tea: cyclic dep: ${dep.project}: ${node.project}`);
                        //TODO the bootstrap should keep the version constraint since it may be different
                        bootstrap.add(dep.project);
                    }
                }
                else {
                    const found = graph[dep.project];
                    if (found) {
                        /// we already traced this graph
                        if (found.count() < node.count()) {
                            found.parent = node;
                        }
                        //FIXME strictly we only have to constrain graphs that contain linkage
                        // ie. you cannot have a binary that links two separate versions of eg. openssl
                        // or (maybe) services, eg. you might suffer if there are two versions of postgres running (though tea mitigates this)
                        found.pkg.constraint = semver.intersect(found.pkg.constraint, dep.constraint);
                    }
                    else {
                        const new_node = new Node(dep, node);
                        graph[dep.project] = new_node;
                        await ascend(new_node, new Set([...children, dep.project]));
                    }
                }
            }
        };
        await ascend(target, new Set([target.project]));
    };
    for (const pkg of dry) {
        if (pkg.project in graph) {
            graph[pkg.project].pkg.constraint = semver.intersect(graph[pkg.project].pkg.constraint, pkg.constraint);
        }
        else {
            const new_node = new Node(pkg);
            graph[pkg.project] = new_node;
            await go(new_node);
        }
    }
    const pkgs = Object.values(graph)
        .sort((a, b) => b.count() - a.count())
        .map(({ pkg }) => pkg);
    //TODO strictly we need to record precisely the bootstrap version constraint
    const bootstrap_required = new Set(pkgs.compact(({ project }) => bootstrap.has(project) && project));
    return {
        pkgs,
        dry: pkgs.filter(({ project }) => initial_set.has(project)),
        wet: pkgs.filter(({ project }) => !initial_set.has(project) || bootstrap_required.has(project)),
        bootstrap_required
    };
}
exports.default = hydrate;
function condense(pkgs) {
    const out = [];
    for (const pkg of pkgs) {
        const found = out.find(x => x.project === pkg.project);
        if (found) {
            found.constraint = semver.intersect(found.constraint, pkg.constraint);
        }
        else {
            out.push(pkg);
        }
    }
    return out;
}
/////////////////////////////////////////////////////////////////////////// lib
class Node {
    constructor(pkg, parent) {
        Object.defineProperty(this, "parent", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "pkg", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "project", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.parent = parent;
        this.pkg = pkg;
        this.project = pkg.project;
    }
    count() {
        let n = 0;
        let node = this;
        // deno-lint-ignore no-cond-assign
        while (node = node?.parent)
            n++;
        return n;
    }
}
