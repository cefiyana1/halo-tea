"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const usePantry_js_1 = __importStar(require("../hooks/usePantry.js"));
const semver = __importStar(require("../utils/semver.js"));
async function default_1(arg0, opts = { providers: true }) {
    arg0 = arg0.trim();
    /// sanitize and reject anything with path components
    if (!arg0 || arg0.includes("/"))
        return;
    const pantry = (0, usePantry_js_1.default)();
    let found;
    const promises = [];
    for await (const entry of pantry.ls()) {
        if (found)
            break;
        const p = pantry.project(entry).provides().then(providers => {
            for (const provider of providers) {
                if (found) {
                    return;
                }
                else if (provider == arg0) {
                    const constraint = new semver.Range("*");
                    found = { ...entry, constraint, shebang: [provider] };
                }
                else if (arg0.startsWith(provider)) {
                    // eg. `node^16` symlink
                    try {
                        const constraint = new semver.Range(arg0.substring(provider.length));
                        found = { ...entry, constraint, shebang: [provider] };
                    }
                    catch {
                        // not a valid semver range; fallthrough
                    }
                }
                else {
                    //TODO more efficient to check the prefix fits arg0 first
                    // eg. if python3 then check if the provides starts with python before
                    // doing all the regex shit. Matters because there's a *lot* of YAMLs
                    let rx = /({{\s*version\.(marketing|major)\s*}})/;
                    let match = provider.match(rx);
                    if (!match?.index)
                        continue;
                    const regx = match[2] == 'major' ? '\\d+' : '\\d+\\.\\d+';
                    const foo = subst(match.index, match.index + match[1].length, provider, `(${regx})`);
                    rx = new RegExp(`^${foo}$`);
                    match = arg0.match(rx);
                    if (match) {
                        const constraint = new semver.Range(`~${match[1]}`);
                        found = { ...entry, constraint, shebang: [arg0] };
                    }
                }
            }
        }).swallow(usePantry_js_1.PantryError);
        promises.push(p);
        if (opts.providers) {
            const pp = pantry.project(entry).provider().then(f => {
                if (!f)
                    return;
                const rv = f(arg0);
                if (rv)
                    found = {
                        ...entry,
                        constraint: new semver.Range('*'),
                        shebang: [...rv, arg0]
                    };
            });
            promises.push(pp);
        }
    }
    if (!found) {
        // if we didnâ€™t find anything yet then we have to wait on the promises
        // otherwise we can ignore them
        await Promise.all(promises);
    }
    if (found) {
        return found;
    }
}
exports.default = default_1;
const subst = function (start, end, input, what) {
    return input.substring(0, start) + what + input.substring(end);
};
