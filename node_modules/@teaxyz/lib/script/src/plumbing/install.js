"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConsoleLogger = void 0;
// deno-lint-ignore-file no-deprecated-deno-api
// ^^ dnt doesn’t support Deno.Command yet so we’re stuck with the deprecated Deno.run for now
const dntShim = __importStar(require("../../_dnt.shims.js"));
const types_js_1 = require("../types.js");
const useOffLicense_js_1 = __importDefault(require("../hooks/useOffLicense.js"));
const useDownload_js_1 = __importDefault(require("../hooks/useDownload.js"));
const flock_node_js_1 = require("../utils/flock.node.js");
const useConfig_js_1 = __importDefault(require("../hooks/useConfig.js"));
const useCellar_js_1 = __importDefault(require("../hooks/useCellar.js"));
const useCache_js_1 = __importDefault(require("../hooks/useCache.js"));
const useFetch_js_1 = __importDefault(require("../hooks/useFetch.js"));
const crypto_1 = require("crypto");
const Path_js_1 = __importDefault(require("../utils/Path.js"));
const deps_js_1 = require("../deps.js");
const { streams: { writeAll } } = deps_js_1.deno;
async function install(pkg, logger) {
    const { project, version } = pkg;
    const cellar = (0, useCellar_js_1.default)();
    const { prefix: tea_prefix, options: { compression } } = (0, useConfig_js_1.default)();
    const stowage = (0, types_js_1.StowageNativeBottle)({ pkg: { project, version }, compression });
    const url = (0, useOffLicense_js_1.default)('s3').url(stowage);
    const tarball = (0, useCache_js_1.default)().path(stowage);
    const shelf = tea_prefix.join(pkg.project);
    logger?.locking?.(pkg);
    const { rid: fd } = await dntShim.Deno.open(shelf.mkdir('p').string);
    await (0, flock_node_js_1.flock)(fd, 'ex');
    try {
        const already_installed = await cellar.has(pkg);
        if (already_installed) {
            // some other tea instance installed us while we were waiting for the lock
            // or potentially we were already installed and the caller is naughty
            logger?.installed?.(already_installed);
            return already_installed;
        }
        logger?.downloading?.({ pkg });
        const tmpdir = Path_js_1.default.mktemp({
            dir: tea_prefix.join(".local/tmp").join(pkg.project),
            prefix: `v${pkg.version}.`
            //NOTE ^^ inside tea prefix to avoid TMPDIR is on a different volume problems
        });
        const tar_args = compression == 'xz' ? 'xJ' : 'xz'; // laughably confusing
        const untar = dntShim.Deno.run({
            cmd: ["tar", tar_args, "--strip-components", (pkg.project.split("/").length + 1).toString()],
            stdin: 'piped', stdout: "inherit", stderr: "inherit",
            cwd: tmpdir.string,
            /// hard coding path to ensure we don’t deadlock trying to use ourselves to untar ourselves
            env: { PATH: "/usr/bin:/bin" }
        });
        const hasher = (0, crypto_1.createHash)("sha256");
        const remote_SHA_promise = remote_SHA(new URL(`${url}.sha256sum`));
        let total;
        let n = 0;
        await (0, useDownload_js_1.default)().download({
            src: url,
            dst: tarball,
            logger: info => {
                logger?.downloading?.({ pkg, ...info });
                total ??= info.total;
            }
        }, blob => {
            n += blob.length;
            hasher.update(blob);
            logger?.installing?.({ pkg, progress: total ? n / total : total });
            return writeAll(untar.stdin, blob);
        });
        untar.stdin.close();
        const untar_exit_status = await untar.status();
        if (!untar_exit_status.success) {
            throw new Error(`tar exited with status ${untar_exit_status.code}`);
        }
        else {
            untar.close(); //TODO should we do this for the error case too or what?
        }
        const computed_hash_value = hasher.digest("hex");
        const checksum = await remote_SHA_promise;
        if (computed_hash_value != checksum) {
            tarball.rm();
            console.error("tea: we deleted the invalid tarball. try again?");
            throw new Error(`sha: expected: ${checksum}, got: ${computed_hash_value}`);
        }
        const path = tmpdir.mv({ to: shelf.join(`v${pkg.version}`) }).chmod(0o755);
        const install = { pkg, path };
        logger?.installed?.(install);
        return install;
    }
    catch (err) {
        tarball.rm(); //FIXME resumable downloads!
        throw err;
    }
    finally {
        logger?.unlocking?.(pkg);
        await (0, flock_node_js_1.flock)(fd, 'un');
        dntShim.Deno.close(fd); // docs aren't clear if we need to do this or not
    }
}
exports.default = install;
async function remote_SHA(url) {
    const rsp = await (0, useFetch_js_1.default)(url);
    if (!rsp.ok)
        throw rsp;
    const txt = await rsp.text();
    return txt.split(' ')[0];
}
// deno-lint-ignore no-explicit-any
function ConsoleLogger(prefix) {
    prefix = prefix ? `${prefix}: ` : "";
    return {
        locking: function () { console.error(`${prefix}locking`, ...arguments); },
        downloading: function () { console.error(`${prefix}downloading`, ...arguments); },
        installing: function () { console.error(`${prefix}installing`, ...arguments); },
        unlocking: function () { console.error(`${prefix}unlocking`, ...arguments); },
        installed: function () { console.error(`${prefix}installed`, ...arguments); }
    };
}
exports.ConsoleLogger = ConsoleLogger;
