"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DownloadError = void 0;
const dntShim = __importStar(require("../../_dnt.shims.js"));
const deps_js_1 = require("../deps.js");
const { crypto: crypto_, streams: { writeAll } } = deps_js_1.deno;
const { toHashString, crypto } = crypto_;
const error_js_1 = require("../utils/error.js");
const useConfig_js_1 = __importDefault(require("./useConfig.js"));
const useFetch_js_1 = __importDefault(require("./useFetch.js"));
const Path_js_1 = __importDefault(require("../utils/Path.js"));
const fs = __importStar(require("fs"));
require("../utils/misc.js");
class DownloadError extends error_js_1.TeaError {
    constructor(status, opts) {
        super(`http: ${status}: ${opts.src}`);
        Object.defineProperty(this, "status", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "src", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "headers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.name = 'DownloadError';
        this.status = status;
        this.src = opts.src;
        this.headers = opts.headers;
    }
}
exports.DownloadError = DownloadError;
const tmpname = (dst) => dst.parent().join(dst.basename() + ".incomplete");
async function download(opts, chunk) {
    const [dst, stream] = await the_meat(opts);
    if (stream || chunk) {
        const reader = stream ?? fs.createReadStream(dst.string);
        const writer = await (() => {
            if (stream) {
                dst.parent().mkdir('p');
                return dntShim.Deno.open(tmpname(dst).string, { write: true, create: true, truncate: true });
            }
        })();
        for await (const blob of reader) {
            const pp = [];
            if (writer)
                pp.push(writeAll(writer, blob));
            if (chunk)
                pp.push(chunk(blob));
            await Promise.all(pp);
        }
        if (reader instanceof fs.ReadStream) {
            reader.close();
        }
        if (writer) {
            writer.close();
            tmpname(dst).mv({ to: dst, force: true });
        }
    }
    return dst;
}
function cache({ for: url }) {
    return (0, useConfig_js_1.default)().cache
        .join(url.protocol.slice(0, -1))
        .join(url.hostname)
        .join(hash())
        .mkdir('p');
    function hash() {
        let key = url.pathname;
        if (url.search)
            key += `?${url.search}`;
        const blob = new TextEncoder().encode(key);
        const hash = crypto.subtle.digestSync("SHA-256", blob);
        return toHashString(hash);
    }
}
function useDownload() {
    return {
        download,
        cache
    };
}
exports.default = useDownload;
/// internal
async function the_meat({ src, logger, headers, dst }) {
    const hash = cache({ for: src });
    const mtime_entry = hash.join("mtime");
    const etag_entry = hash.join("etag");
    dst ??= hash.join(new Path_js_1.default(src.pathname).basename());
    if (logger)
        logger({ src, dst });
    if (dst.isReadableFile()) {
        headers ??= {};
        if (etag_entry.isFile()) {
            headers["If-None-Match"] = await etag_entry.read();
        }
        // sending both if we have them is ChatGPT recommended
        // also this fixes getting the mysql.com sources, otherwise it redownloads 400MB every time!
        if (mtime_entry.isFile()) {
            headers["If-Modified-Since"] = await mtime_entry.read();
        }
    }
    if (logger)
        logger({ src, dst });
    const rsp = await (0, useFetch_js_1.default)(src, { headers });
    switch (rsp.status) {
        case 200: {
            const sz = parseInt(rsp.headers.get("Content-Length")).chuzzle();
            if (logger)
                logger({ src, dst, total: sz });
            const reader = rsp.body ?? (0, error_js_1.panic)();
            const text = rsp.headers.get("Last-Modified");
            if (text)
                mtime_entry.write({ text, force: true });
            const etag = rsp.headers.get("ETag");
            if (etag)
                etag_entry.write({ text: etag, force: true });
            if (!logger) {
                return [dst, reader, sz];
            }
            else {
                let n = 0;
                return [dst, reader.pipeThrough(new dntShim.TransformStream({
                        transform: (buf, controller) => {
                            n += buf.length;
                            logger({ src, dst: dst, rcvd: n, total: sz });
                            controller.enqueue(buf);
                        }
                    })), sz];
            }
        }
        case 304: {
            const sz = (await dntShim.Deno.stat(dst.string)).size;
            if (logger)
                logger({ src, dst, rcvd: sz, total: sz });
            return [dst, undefined, sz];
        }
        default:
            throw new DownloadError(rsp.status, { src, headers });
    }
}
