"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.expand_env_obj = exports.parse_pkgs_node = exports.PantryNotFoundError = exports.PackageNotFoundError = exports.PantryParseError = exports.PantryError = void 0;
const dntShim = __importStar(require("../../_dnt.shims.js"));
const deps_js_1 = require("../deps.js");
const { isNumber, isPlainObject, isString, isArray, isPrimitive, isBoolean } = deps_js_1.is_what;
const hacks_js_1 = require("../utils/hacks.js");
const useMoustaches_js_1 = __importDefault(require("./useMoustaches.js"));
const error_js_1 = require("../utils/error.js");
const misc_js_1 = require("../utils/misc.js");
const useConfig_js_1 = __importDefault(require("./useConfig.js"));
const host_js_1 = __importDefault(require("../utils/host.js"));
const Path_js_1 = __importDefault(require("../utils/Path.js"));
class PantryError extends error_js_1.TeaError {
}
exports.PantryError = PantryError;
class PantryParseError extends PantryError {
    constructor(project, path, cause) {
        super(`package.yml parse error: ${path ?? project}`);
        Object.defineProperty(this, "project", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "path", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.project = project;
        this.path = path;
        this.cause = cause;
    }
}
exports.PantryParseError = PantryParseError;
class PackageNotFoundError extends PantryError {
    constructor(project) {
        super(`pkg not found: ${project}`);
        Object.defineProperty(this, "project", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.project = project;
    }
}
exports.PackageNotFoundError = PackageNotFoundError;
class PantryNotFoundError extends PantryError {
    constructor(path) {
        super(`pantry not found: ${path}`);
    }
}
exports.PantryNotFoundError = PantryNotFoundError;
function usePantry() {
    const config = (0, useConfig_js_1.default)();
    const prefix = config.prefix.join('tea.xyz/var/pantry/projects');
    async function* ls() {
        for (const prefix of pantry_paths()) {
            for await (const path of _ls_pantry(prefix)) {
                yield {
                    project: path.parent().relative({ to: prefix }),
                    path
                };
            }
        }
    }
    const project = (input) => {
        const project = isString(input) ? input : input.project;
        const yaml = (() => {
            for (const prefix of pantry_paths()) {
                if (!prefix.exists())
                    throw new PantryNotFoundError(prefix.parent());
                const dir = prefix.join(project);
                const filename = dir.join("package.yml");
                if (!filename.exists())
                    continue;
                let memo;
                return () => memo ?? (memo = filename.readYAML()
                    .then(misc_js_1.validate.obj)
                    .catch(cause => { throw new PantryParseError(project, filename, cause); }));
            }
            throw new PackageNotFoundError(project);
        })();
        const companions = async () => parse_pkgs_node((await yaml())["companions"]);
        const runtime_env = async (version, deps) => {
            const yml = await yaml();
            const obj = misc_js_1.validate.obj(yml["runtime"]?.["env"] ?? {});
            return expand_env_obj(obj, { project, version }, deps);
        };
        const available = async () => {
            let { platforms } = await yaml();
            if (!platforms)
                return true;
            if (isString(platforms))
                platforms = [platforms];
            if (!isArray(platforms))
                throw new PantryParseError(project);
            return platforms.includes((0, host_js_1.default)().platform) || platforms.includes(`${(0, host_js_1.default)().platform}/${(0, host_js_1.default)().arch}`);
        };
        const drydeps = async () => parse_pkgs_node((await yaml()).dependencies);
        const provides = async () => {
            let node = (await yaml())["provides"];
            if (!node)
                return [];
            if (isPlainObject(node)) {
                node = node[(0, host_js_1.default)().platform];
            }
            if (!isArray(node))
                throw new PantryParseError(project);
            return node.compact(x => {
                if (isPlainObject(x)) {
                    x = x["executable"];
                }
                if (isString(x)) {
                    if (x.startsWith("bin/"))
                        return x.slice(4);
                    if (x.startsWith("sbin/"))
                        return x.slice(5);
                }
            });
        };
        const provider = async () => {
            for (const prefix of pantry_paths()) {
                if (!prefix.exists())
                    continue;
                const dir = prefix.join(project);
                const filename = dir.join("provider.yml");
                if (!filename.exists())
                    continue;
                const yaml = misc_js_1.validate.obj(await filename.readYAML());
                const cmds = misc_js_1.validate.arr(yaml.cmds);
                return (binname) => {
                    if (!cmds.includes(binname))
                        return;
                    const args = yaml['args'];
                    if (isPlainObject(args)) {
                        if (args[binname]) {
                            return get_args(args[binname]);
                        }
                        else {
                            return get_args(args['...']);
                        }
                    }
                    else {
                        return get_args(args);
                    }
                };
            }
            function get_args(input) {
                if (isString(input)) {
                    return input.split(/\s+/);
                }
                else {
                    return misc_js_1.validate.arr(input);
                }
            }
        };
        return {
            companions,
            runtime: {
                env: runtime_env,
                deps: drydeps
            },
            available,
            provides,
            provider,
            yaml
        };
    };
    async function which({ interprets: extension }) {
        if (extension[0] == '.')
            extension = extension.slice(1);
        if (!extension)
            return;
        for await (const pkg of ls()) {
            const yml = await project(pkg).yaml();
            const node = yml["interprets"];
            if (!isPlainObject(node))
                continue;
            try {
                const { extensions, args } = yml["interprets"];
                if ((isString(extensions) && extensions === extension) ||
                    (isArray(extensions) && extensions.includes(extension))) {
                    return { project: pkg.project, args: isArray(args) ? args : [args] };
                }
            }
            catch {
                continue;
            }
        }
        return undefined;
    }
    const missing = () => !prefix.exists();
    const neglected = () => {
        const stat = dntShim.Deno.statSync(prefix.string);
        if (!stat.mtime)
            return true;
        return (Date.now() - stat.mtime.getTime()) > 24 * 60 * 60 * 1000;
    };
    return {
        prefix,
        which,
        ls,
        project,
        parse_pkgs_node,
        expand_env_obj,
        missing,
        neglected
    };
    function pantry_paths() {
        const rv = [];
        if (prefix.isDirectory()) {
            rv.push(prefix);
        }
        for (const path of config.pantries.reverse()) {
            rv.unshift(path.join("projects"));
        }
        if (rv.length == 0) {
            throw new PantryNotFoundError(prefix);
        }
        return rv;
    }
}
exports.default = usePantry;
// deno-lint-ignore no-explicit-any
function parse_pkgs_node(node) {
    if (!node)
        return [];
    node = misc_js_1.validate.obj(node);
    platform_reduce(node);
    return Object.entries(node)
        .compact(([project, constraint]) => (0, hacks_js_1.validatePackageRequirement)(project, constraint));
}
exports.parse_pkgs_node = parse_pkgs_node;
/// expands platform specific keys into the object
/// expands inplace because JS is nuts and you have to suck it up
function platform_reduce(env) {
    const sys = (0, host_js_1.default)();
    for (const [key, value] of Object.entries(env)) {
        const [os, arch] = (() => {
            let match = key.match(/^(darwin|linux)\/(aarch64|x86-64)$/);
            if (match)
                return [match[1], match[2]];
            if ((match = key.match(/^(darwin|linux)$/)))
                return [match[1]];
            if ((match = key.match(/^(aarch64|x86-64)$/)))
                return [, match[1]];
            return [];
        })();
        if (!os && !arch)
            continue;
        delete env[key];
        if (os && os != sys.platform)
            continue;
        if (arch && arch != sys.arch)
            continue;
        const dict = misc_js_1.validate.obj(value);
        for (const [key, value] of Object.entries(dict)) {
            // if user specifies an array then we assume we are supplementing
            // otherwise we are replacing. If this is too magical let us know
            if (isArray(value)) {
                if (!env[key])
                    env[key] = [];
                else if (!isArray(env[key]))
                    env[key] = [env[key]];
                //TODO if all-platforms version comes after the specific then order accordingly
                env[key].push(...value);
            }
            else {
                env[key] = value;
            }
        }
    }
}
function expand_env_obj(env_, pkg, deps) {
    const env = { ...env_ };
    platform_reduce(env);
    const rv = {};
    for (let [key, value] of Object.entries(env)) {
        if (isArray(value)) {
            value = value.map(x => transform(x)).join(" ");
        }
        else {
            value = transform(value);
        }
        rv[key] = value;
    }
    return rv;
    // deno-lint-ignore no-explicit-any
    function transform(value) {
        if (!isPrimitive(value))
            throw new PantryParseError(pkg.project, undefined, JSON.stringify(value));
        if (isBoolean(value)) {
            return value ? "1" : "0";
        }
        else if (value === undefined || value === null) {
            return "0";
        }
        else if (isString(value)) {
            const mm = (0, useMoustaches_js_1.default)();
            const home = Path_js_1.default.home().string;
            const obj = [
                { from: 'env.HOME', to: home },
                { from: 'home', to: home } // remove, stick with just ~
            ];
            obj.push(...mm.tokenize.all(pkg, deps));
            return mm.apply(value, obj);
        }
        else if (isNumber(value)) {
            return value.toString();
        }
        const e = new Error("unexpected error");
        e.cause = value;
        throw e;
    }
}
exports.expand_env_obj = expand_env_obj;
async function* _ls_pantry(dir) {
    if (!dir.isDirectory())
        throw new PantryNotFoundError(dir);
    for await (const [path, { name, isDirectory }] of dir.ls()) {
        if (isDirectory) {
            for await (const x of _ls_pantry(path)) {
                yield x;
            }
        }
        else if (name === "package.yml" || name === "package.yaml") {
            yield path;
        }
    }
}
