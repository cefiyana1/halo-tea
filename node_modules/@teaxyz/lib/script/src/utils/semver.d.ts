/**
 * we have our own implementation because open source is full of weird
 * but *almost* valid semver schemes, eg:
   * openssl 1.1.1q
   * ghc 5.64.3.2
 * it also allows us to implement semver_intersection without hating our lives
 */
export default class SemVer {
    readonly components: number[];
    major: number;
    minor: number;
    patch: number;
    readonly prerelease: string[];
    readonly build: string[];
    readonly raw: string;
    readonly pretty?: string;
    constructor(input: string | number[] | Range | SemVer);
    toString(): string;
    eq(that: SemVer): boolean;
    neq(that: SemVer): boolean;
    gt(that: SemVer): boolean;
    gte(that: SemVer): boolean;
    lt(that: SemVer): boolean;
    lte(that: SemVer): boolean;
    compare(that: SemVer): number;
}
export declare function parse(input: string): SemVer | undefined;
export declare function isValid(input: string): boolean;
export declare class Range {
    readonly set: ([SemVer, SemVer] | SemVer)[] | '*';
    constructor(input: string | ([SemVer, SemVer] | SemVer)[]);
    toString(): string;
    static parse(input: string | number): Range | undefined;
    satisfies(version: SemVer): boolean;
    max(versions: SemVer[]): SemVer | undefined;
    single(): SemVer | undefined;
}
declare function _compare(a: SemVer, b: SemVer): number;
export { _compare as compare };
export declare function intersect(a: Range, b: Range): Range;
export declare const regex: RegExp;
