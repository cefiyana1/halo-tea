"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const dntShim = __importStar(require("../../_dnt.shims.js"));
const deps_js_1 = require("../deps.js");
const fs_1 = require("fs");
const sys = __importStar(require("path"));
const os = __importStar(require("os"));
const { io: { readLines }, fs, parseYaml } = deps_js_1.deno;
// modeled after https://github.com/mxcl/Path.swift
// everything is Sync because TypeScript will unfortunately not
// cascade `await`, meaning our chainable syntax would become:
//
//     await (await foo).bar
//
// however we use async versions for “terminators”, eg. `ls()`
class Path {
    static cwd() {
        return new Path(dntShim.Deno.cwd());
    }
    static home() {
        return new Path((() => {
            switch (dntShim.Deno.build.os) {
                case "windows":
                    return dntShim.Deno.env.get("USERPROFILE");
                default:
                    return dntShim.Deno.env.get("HOME");
            }
        })());
    }
    /// normalizes the path
    /// throws if not an absolute path
    constructor(input) {
        /// the normalized string representation of the underlying filesystem path
        Object.defineProperty(this, "string", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (input instanceof Path) {
            this.string = input.string;
        }
        else if (!input || input[0] != '/') {
            throw new Error(`invalid absolute path: ${input}`);
        }
        else {
            this.string = sys.normalize(input);
            // ^^ seemingly doesn’t normalize trailing slashes away
            if (this.string != "/")
                while (this.string.endsWith("/")) {
                    this.string = this.string.slice(0, -1);
                }
        }
    }
    /// returns Path | undefined rather than throwing error if Path is not absolute
    static abs(input) {
        try {
            return new Path(input);
        }
        catch {
            return;
        }
    }
    /**
      If the path represents an actual entry that is a symlink, returns the symlink’s
      absolute destination.
  
      - Important: This is not exhaustive, the resulting path may still contain a symlink.
      - Important: The path will only be different if the last path component is a symlink, any symlinks in prior components are not resolved.
      - Note: If file exists but isn’t a symlink, returns `self`.
      - Note: If symlink destination does not exist, is **not** an error.
      */
    readlink() {
        try {
            const output = dntShim.Deno.readLinkSync(this.string);
            return this.parent().join(output);
        }
        catch (err) {
            const code = err.code;
            switch (code) {
                case 'EINVAL':
                    return this; // is file
                case 'ENOENT':
                    throw err; // there is no symlink at this path
            }
            throw err;
        }
    }
    /**
      Returns the parent directory for this path.
      Path is not aware of the nature of the underlying file, but this is
      irrlevant since the operation is the same irrespective of this fact.
      - Note: always returns a valid path, `Path.root.parent` *is* `Path.root`.
      */
    parent() {
        return new Path(sys.dirname(this.string));
    }
    /// returns normalized absolute path string
    toString() {
        return this.string;
    }
    /// joins this path with the provided component and normalizes it
    /// if you provide an absolute path that path is returned
    /// rationale: usually if you are trying to join an absolute path it is a bug in your code
    /// TODO should warn tho
    join(...components) {
        const joined = components.filter(x => x).join("/");
        if (joined[0] == '/') {
            return new Path(joined);
        }
        else if (joined) {
            return new Path(`${this.string}/${joined}`);
        }
        else {
            return this;
        }
    }
    /// Returns true if the path represents an actual filesystem entry that is *not* a directory.
    /// NOTE we use `stat`, so if the file is a symlink it is resolved, usually this is what you want
    isFile() {
        try {
            return dntShim.Deno.statSync(this.string).isFile ? this : undefined;
        }
        catch {
            return; //FIXME
            // if (err instanceof Deno.errors.NotFound == false) {
            //   throw err
            // }
        }
    }
    isSymlink() {
        try {
            return dntShim.Deno.lstatSync(this.string).isSymlink ? this : undefined;
        }
        catch {
            return; //FIXME
            // if (err instanceof Deno.errors.NotFound) {
            //   return false
            // } else {
            //   throw err
            // }
        }
    }
    isExecutableFile() {
        try {
            if (!this.isFile())
                return;
            const info = dntShim.Deno.statSync(this.string);
            if (!info.mode)
                throw new Error();
            const is_exe = (info.mode & 0o111) > 0;
            if (is_exe)
                return this;
        }
        catch {
            return; //FIXME catch specific errors
        }
    }
    isReadableFile() {
        return this.isFile() /*FIXME*/ ? this : undefined;
    }
    exists() {
        //FIXME can be more efficient
        try {
            dntShim.Deno.statSync(this.string);
            return this;
        }
        catch {
            return; //FIXME
            // if (err instanceof Deno.errors.NotFound) {
            //   return false
            // } else {
            //   throw err
            // }
        }
    }
    /// Returns true if the path represents an actual directory.
    /// NOTE we use `stat`, so if the file is a symlink it is resolved, usually this is what you want
    isDirectory() {
        try {
            return dntShim.Deno.statSync(this.string).isDirectory ? this : undefined;
        }
        catch {
            return; //FIXME catch specific errorrs
        }
    }
    async *ls() {
        for await (const entry of dntShim.Deno.readDir(this.string)) {
            yield [this.join(entry.name), entry];
        }
    }
    //FIXME probs can be infinite
    async *walk() {
        const stack = [this];
        while (stack.length > 0) {
            const dir = stack.pop();
            for await (const entry of dntShim.Deno.readDir(dir.string)) {
                const path = dir.join(entry.name);
                yield [path, entry];
                if (entry.isDirectory) {
                    stack.push(path);
                }
            }
        }
    }
    components() {
        return this.string.split('/');
    }
    static mktemp(opts) {
        let { prefix, dir } = opts ?? {};
        dir ??= new Path(os.tmpdir());
        prefix ??= "";
        if (!prefix.startsWith('/'))
            prefix = `/${prefix}`;
        // not using deno.makeTempDirSync because it's bugg’d and the node shim doesn’t handler `dir`
        const rv = (0, fs_1.mkdtempSync)(`${dir.mkdir('p')}${prefix}`);
        return new Path(rv);
    }
    split() {
        const d = this.parent();
        const b = this.basename();
        return [d, b];
    }
    /// the file extension with the leading period
    extname() {
        const match = this.string.match(/\.tar\.\w+$/);
        if (match) {
            return match[0];
        }
        else {
            return sys.extname(this.string);
        }
    }
    basename() {
        return sys.basename(this.string);
    }
    /**
      Moves a file.
  
          Path.root.join("bar").mv({to: Path.home.join("foo")})
          // => Path("/Users/mxcl/foo")
  
      - Parameter to: Destination filename.
      - Parameter into: Destination directory (you get `into/${this.basename()`)
      - Parameter overwrite: If true overwrites any entry that already exists at the destination.
      - Returns: `to` to allow chaining.
      - Note: `force` will still throw if `to` is a directory.
      - Note: Throws if `overwrite` is `false` yet `to` is *already* identical to
        `self` because even though *our policy* is to noop if the desired
        end result preexists, checking for this condition is too expensive a
        trade-off.
      */
    mv({ force, ...opts }) {
        if ("to" in opts) {
            fs.moveSync(this.string, opts.to.string, { overwrite: force });
            return opts.to;
        }
        else {
            const dst = opts.into.join(this.basename());
            fs.moveSync(this.string, dst.string, { overwrite: force });
            return dst;
        }
    }
    //FIXME operates in ”force” mode
    //TODO needs a recursive option
    cp({ into }) {
        const dst = into.join(this.basename());
        dntShim.Deno.copyFileSync(this.string, dst.string);
        return dst;
    }
    rm({ recursive } = { recursive: false }) {
        if (this.exists()) {
            try {
                dntShim.Deno.removeSync(this.string, { recursive });
            }
            catch (err) {
                if (this.exists()) {
                    throw err;
                }
                else {
                    // this is what we wanted, so noop
                }
            }
        }
        return this; // may seem weird but I've had cases where I wanted to chain
    }
    mkdir(opts) {
        if (!this.isDirectory()) {
            dntShim.Deno.mkdirSync(this.string, { recursive: opts == 'p' });
        }
        return this;
    }
    isEmpty() {
        for (const _ of dntShim.Deno.readDirSync(this.string)) {
            return;
        }
        return this;
    }
    eq(that) {
        return this.string == that.string;
    }
    neq(that) {
        return this.string != that.string;
    }
    /// `this` is the symlink that is created pointing at `target`
    /// in Path.ts we always create `this`, our consistency helps with the notoriously difficuly argument order of `ln -s`
    /// note symlink is full and absolute path
    ln(_, { target }) {
        dntShim.Deno.symlinkSync(target.string, this.string);
        return this;
    }
    read() {
        return dntShim.Deno.readTextFile(this.string);
    }
    async *readLines() {
        const fd = dntShim.Deno.openSync(this.string);
        try {
            for await (const line of readLines(fd))
                yield line;
        }
        finally {
            fd.close();
        }
    }
    //FIXME like, we don’t want a hard dependency in the published library
    //TODO would be nice to validate the output against a type
    //TODO shouldn't be part of this module since we want to publish it
    async readYAML() {
        try {
            const txt = await this.read();
            return parseYaml(txt, { filename: this.string /*improves err msgs*/ });
        }
        catch (err) {
            err.cause = this.string;
            throw err;
        }
    }
    readJSON() {
        return this.read().then(x => JSON.parse(x));
    }
    write({ force, ...content }) {
        if (this.exists()) {
            if (!force)
                throw new Error(`file-exists:${this}`);
            this.rm();
        }
        if ("text" in content) {
            dntShim.Deno.writeTextFileSync(this.string, content.text);
        }
        else {
            const text = JSON.stringify(content.json, null, content.space);
            dntShim.Deno.writeTextFileSync(this.string, text);
        }
        return this;
    }
    touch() {
        //FIXME work more as expected
        return this.write({ force: true, text: "" });
    }
    chmod(mode) {
        dntShim.Deno.chmodSync(this.string, mode);
        return this;
    }
    chuzzle() {
        if (this.exists())
            return this;
    }
    relative({ to: base }) {
        const pathComps = ['/'].concat(this.string.split("/").filter(x => x));
        const baseComps = ['/'].concat(base.string.split("/").filter(x => x));
        if (this.string.startsWith(base.string)) {
            return pathComps.slice(baseComps.length).join("/");
        }
        else {
            const newPathComps = [...pathComps];
            const newBaseComps = [...baseComps];
            while (newPathComps[0] == newBaseComps[0]) {
                newPathComps.shift();
                newBaseComps.shift();
            }
            const relComps = Array.from({ length: newBaseComps.length }, () => "..");
            relComps.push(...newPathComps);
            return relComps.join("/");
        }
    }
    realpath() {
        return new Path(dntShim.Deno.realPathSync(this.string));
    }
    prettyString() {
        return this.string.replace(new RegExp(`^${Path.home()}`), '~');
    }
    // if we’re inside the CWD we print that
    prettyLocalString() {
        const cwd = Path.cwd();
        return this.string.startsWith(cwd.string) ? `./${this.relative({ to: cwd })}` : this.prettyString();
    }
    [Symbol.for("Deno.customInspect")]() {
        return this.prettyString();
    }
}
/// the filesystem root
Object.defineProperty(Path, "root", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: new Path("/")
});
exports.default = Path;
