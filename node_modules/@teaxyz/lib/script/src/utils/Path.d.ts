import * as dntShim from "../../_dnt.shims.js";
import { PlainObject } from "../deps.js";
export default class Path {
    readonly string: string;
    static root: Path;
    static cwd(): Path;
    static home(): Path;
    constructor(input: string | Path);
    static abs(input: string | Path): Path | undefined;
    /**
      If the path represents an actual entry that is a symlink, returns the symlink’s
      absolute destination.
  
      - Important: This is not exhaustive, the resulting path may still contain a symlink.
      - Important: The path will only be different if the last path component is a symlink, any symlinks in prior components are not resolved.
      - Note: If file exists but isn’t a symlink, returns `self`.
      - Note: If symlink destination does not exist, is **not** an error.
      */
    readlink(): Path;
    /**
      Returns the parent directory for this path.
      Path is not aware of the nature of the underlying file, but this is
      irrlevant since the operation is the same irrespective of this fact.
      - Note: always returns a valid path, `Path.root.parent` *is* `Path.root`.
      */
    parent(): Path;
    toString(): string;
    join(...components: string[]): Path;
    isFile(): Path | undefined;
    isSymlink(): Path | undefined;
    isExecutableFile(): Path | undefined;
    isReadableFile(): Path | undefined;
    exists(): Path | undefined;
    isDirectory(): Path | undefined;
    ls(): AsyncIterable<[Path, dntShim.Deno.DirEntry]>;
    walk(): AsyncIterable<[Path, dntShim.Deno.DirEntry]>;
    components(): string[];
    static mktemp(opts?: {
        prefix?: string;
        dir?: Path;
    }): Path;
    split(): [Path, string];
    extname(): string;
    basename(): string;
    /**
      Moves a file.
  
          Path.root.join("bar").mv({to: Path.home.join("foo")})
          // => Path("/Users/mxcl/foo")
  
      - Parameter to: Destination filename.
      - Parameter into: Destination directory (you get `into/${this.basename()`)
      - Parameter overwrite: If true overwrites any entry that already exists at the destination.
      - Returns: `to` to allow chaining.
      - Note: `force` will still throw if `to` is a directory.
      - Note: Throws if `overwrite` is `false` yet `to` is *already* identical to
        `self` because even though *our policy* is to noop if the desired
        end result preexists, checking for this condition is too expensive a
        trade-off.
      */
    mv({ force, ...opts }: {
        to: Path;
        force?: boolean;
    } | {
        into: Path;
        force?: boolean;
    }): Path;
    cp({ into }: {
        into: Path;
    }): Path;
    rm({ recursive }?: {
        recursive: boolean;
    }): this;
    mkdir(opts?: 'p'): Path;
    isEmpty(): Path | undefined;
    eq(that: Path): boolean;
    neq(that: Path): boolean;
    ln(_: 's', { target }: {
        target: Path;
    }): Path;
    read(): Promise<string>;
    readLines(): AsyncIterableIterator<string>;
    readYAML(): Promise<unknown>;
    readJSON(): Promise<unknown>;
    write({ force, ...content }: ({
        text: string;
    } | {
        json: PlainObject;
        space?: number;
    }) & {
        force?: boolean;
    }): Path;
    touch(): Path;
    chmod(mode: number): Path;
    chuzzle(): Path | undefined;
    relative({ to: base }: {
        to: Path;
    }): string;
    realpath(): Path;
    prettyString(): string;
    prettyLocalString(): string;
}
