"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConsoleLogger = void 0;
const install_js_1 = __importStar(require("../plumbing/install.js"));
const resolve_js_1 = __importDefault(require("../plumbing/resolve.js"));
const usePantry_js_1 = __importDefault(require("../hooks/usePantry.js"));
const hydrate_js_1 = __importDefault(require("../plumbing/hydrate.js"));
const useSync_js_1 = __importDefault(require("../hooks/useSync.js"));
const pkg_js_1 = require("../utils/pkg.js");
const link_js_1 = __importDefault(require("../plumbing/link.js"));
const deps_js_1 = require("../deps.js");
const { isString } = deps_js_1.is_what;
// deno-lint-ignore no-explicit-any
function ConsoleLogger(prefix) {
    prefix = prefix ? `${prefix}: ` : "";
    return {
        ...(0, install_js_1.ConsoleLogger)(prefix),
        progress: function () { console.error(`${prefix}progress`, ...arguments); },
    };
}
exports.ConsoleLogger = ConsoleLogger;
/// eg. install("python.org~3.10")
async function default_1(pkgs, logger) {
    if (isString(pkgs))
        pkgs = pkgs.split(/\s+/);
    pkgs = pkgs.map(pkg => isString(pkg) ? (0, pkg_js_1.parse)(pkg) : pkg);
    const pantry = (0, usePantry_js_1.default)();
    if (pantry.missing() || pantry.neglected()) {
        await (0, useSync_js_1.default)();
    }
    //TODO parallelize!
    pkgs = (await (0, hydrate_js_1.default)(pkgs)).pkgs;
    const resolution = await (0, resolve_js_1.default)(pkgs);
    logger?.resolved?.(resolution);
    const { pending, installed } = resolution;
    logger = WrapperLogger(pending, logger);
    const installers = pending
        .map(pkg => (0, install_js_1.default)(pkg, logger)
        .then(i => (0, link_js_1.default)(i).then(() => i)));
    installed.push(...await Promise.all(installers));
    return installed;
}
exports.default = default_1;
function WrapperLogger(pending, logger) {
    if (!logger?.progress)
        return logger;
    const projects = pending.map(pkg => pkg.project);
    const totals = {};
    const progresses = {};
    return {
        ...logger,
        downloading: args => {
            const { pkg: { project }, total } = args;
            if (total) {
                totals[project] = total;
                updateProgress();
            }
            if (logger?.downloading) {
                logger.downloading(args);
            }
        },
        installing: args => {
            const { pkg: { project }, progress } = args;
            if (progress) {
                progresses[project] = progress;
                updateProgress();
            }
            if (logger?.installing) {
                logger.installing(args);
            }
        }
    };
    function updateProgress() {
        let total_untard_bytes = 0;
        let grand_total = 0;
        for (const project of projects) {
            const total = totals[project];
            const bytes = progresses[project] * total;
            total_untard_bytes += bytes;
            grand_total += total;
        }
        const rv = total_untard_bytes / grand_total;
        if (!isNaN(rv)) {
            logger.progress(total_untard_bytes / grand_total);
        }
    }
}
