"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RunError = void 0;
const dntShim = __importStar(require("../../_dnt.shims.js"));
const install_js_1 = __importDefault(require("../plumbing/install.js"));
const useShellEnv_js_1 = __importDefault(require("../hooks/useShellEnv.js"));
const usePantry_js_1 = __importDefault(require("../hooks/usePantry.js"));
const hydrate_js_1 = __importDefault(require("../plumbing/hydrate.js"));
const resolve_js_1 = __importDefault(require("../plumbing/resolve.js"));
const error_js_1 = require("../utils/error.js");
const child_process_1 = require("child_process");
const useSync_js_1 = __importDefault(require("../hooks/useSync.js"));
const which_js_1 = __importDefault(require("../plumbing/which.js"));
const link_js_1 = __importDefault(require("../plumbing/link.js"));
const deps_js_1 = require("../deps.js");
const { isArray } = deps_js_1.is_what;
async function run(cmd, opts) {
    const { usesh, arg0: whom } = (() => {
        if (!isArray(cmd)) {
            const s = cmd.trim();
            const i = s.indexOf(' ');
            if (i == -1) {
                cmd = [];
                return { usesh: false, arg0: s };
            }
            else {
                const arg0 = s.slice(0, i);
                cmd = s.slice(i + 1);
                return { usesh: true, arg0 };
            }
        }
        else if (cmd.length == 0) {
            throw new RunError('EUSAGE', `\`cmd\` evaluated empty: ${cmd}`);
        }
        else {
            return {
                usesh: false,
                arg0: cmd.shift().toString().trim()
            };
        }
    })();
    const { env, shebang } = await setup(whom, opts?.env ?? dntShim.Deno.env.toObject(), opts?.logger);
    const arg0 = usesh ? '/bin/sh' : shebang.shift();
    const args = usesh
        ? ['-c', `${shebang.join(' ')} ${cmd}`]
        : [...shebang, ...cmd.map(x => x.toString())];
    return new Promise((resolve, reject) => {
        const proc = (0, child_process_1.spawn)(arg0, args, {
            env,
            stdio: [
                "pipe",
                opts?.stdout ? 'pipe' : 'inherit',
                opts?.stderr ? 'pipe' : 'inherit'
            ]
        });
        let stdout = '', stderr = '';
        proc.stdout?.on('data', data => stdout += data);
        proc.stderr?.on('data', data => stderr += data);
        proc.on('close', status => {
            if (status && !opts?.status) {
                const err = new RunError('EIO', `${cmd} exited with: ${status}`);
                err.cause = status;
                reject(err);
            }
            else {
                const fulfill = resolve;
                fulfill({ stdout, stderr, status });
            }
        });
    });
}
exports.default = run;
async function setup(cmd, env, logger) {
    const pantry = (0, usePantry_js_1.default)();
    const sh = (0, useShellEnv_js_1.default)();
    if (pantry.missing() || pantry.neglected()) {
        await (0, useSync_js_1.default)();
    }
    const wut = await (0, which_js_1.default)(cmd);
    if (!wut)
        throw new RunError('ENOENT', `No project in pantry provides ${cmd}`);
    const { pkgs } = await (0, hydrate_js_1.default)(wut);
    const { pending, installed } = await (0, resolve_js_1.default)(pkgs);
    for (const pkg of pending) {
        const installation = await (0, install_js_1.default)(pkg, logger);
        await (0, link_js_1.default)(installation);
        installed.push(installation);
    }
    const pkgenv = await sh.map({ installations: installed });
    for (const [key, value] of Object.entries(env)) {
        if (!value) {
            continue;
        }
        else if (pkgenv[key]) {
            pkgenv[key].push(value);
        }
        else {
            pkgenv[key] = [value];
        }
    }
    return { env: sh.flatten(pkgenv), shebang: wut.shebang };
}
class RunError extends error_js_1.TeaError {
    constructor(code, message) {
        super(message);
        Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.code = code;
    }
}
exports.RunError = RunError;
